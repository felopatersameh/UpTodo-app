import 'dart:async';import 'dart:io';import 'package:device_info_plus/device_info_plus.dart';import 'package:flutter_local_notifications/flutter_local_notifications.dart';import 'package:permission_handler/permission_handler.dart';import 'package:timezone/data/latest_all.dart' as tz;import 'package:timezone/timezone.dart' as tz;//* sound//* send in time created [ Show notification Now ]//* ==> on tab//* send message daily at 10 am (to reminders of do tasks tomorrow) => [scheduleDailyNotification ]//* send message daily of tasks today before tasks time is ending (to reminders of do tasks) => [scheduleDailyNotification]//* send what is new upgrade if installed// Top-level background handler@pragma('vm:entry-point') // Required for background callbacksvoid _onNotificationTap(NotificationResponse? response) {  final String? payload = response?.payload;  if (payload != null) {    // Send payload to the stream    NotificationManager.notificationStreamController.add(response);    // Add additional logic, e.g., navigation:    // print('Notification clicked with payload: $payload');  }}class NotificationManager {  static final NotificationManager _instance = NotificationManager._internal();  factory NotificationManager() => _instance;  NotificationManager._internal();  final FlutterLocalNotificationsPlugin _flutterLocalNotificationsPlugin =      FlutterLocalNotificationsPlugin();  static const String _defaultChannelId = 'Initiative';  static const String _defaultChannelName = 'UpToDo Notifications';  static const String _defaultChannelDescription = 'TO Do App Tasks Higher ';  static final StreamController<NotificationResponse?>      notificationStreamController = StreamController.broadcast();  // Expose notification stream for app-wide access  Stream<NotificationResponse?> get notificationStream =>      notificationStreamController.stream;  Future<void> initialize() async {    tz.initializeTimeZones();    const AndroidInitializationSettings androidInitSettings =        AndroidInitializationSettings('@mipmap/ic_launcher');    const InitializationSettings initializationSettings =        InitializationSettings(android: androidInitSettings);    await _flutterLocalNotificationsPlugin.initialize(      initializationSettings,      onDidReceiveNotificationResponse: _onNotificationTap,      onDidReceiveBackgroundNotificationResponse: _onNotificationTap,    );    await createNotificationChannel(      channelId: _defaultChannelId,      channelName: _defaultChannelName,      channelDescription: _defaultChannelDescription,    );    await requestNotificationPermission();    // print("NotificationManager Initialized");  }  Future<void> requestNotificationPermission() async {    if (!Platform.isAndroid) {      return;    }    final androidInfo = await DeviceInfoPlugin().androidInfo;    final androidVersion = androidInfo.version.release;    // Request notification permission    final notificationStatus = await Permission.notification.request();    // Handle permission status    if (notificationStatus.isGranted) {      // print("Notification permission granted.");      return;    }    // } else if (notificationStatus.isDenied) {    //   print("Notification permission denied. Notifications may not work properly.");    // } else    if (notificationStatus.isPermanentlyDenied) {      print(          "Notification permission permanently denied. Redirecting to settings...");      await openAppSettings();    }    // Request additional permissions for Android 31 and 32    if (androidVersion.compareTo('31') >= 0 &&        androidVersion.compareTo('32') <= 0) {      final alarmStatus = await Permission.scheduleExactAlarm.request();      if (alarmStatus.isPermanentlyDenied) {        // print("Exact Alarm permission permanently denied. Redirecting to settings...");        await openAppSettings();      }    }  }  Future<void> createNotificationChannel({    required String channelId,    required String channelName,    String? channelDescription,    Importance importance = Importance.high,  }) async {    final AndroidNotificationChannel channel = AndroidNotificationChannel(      channelId,      channelName,      description: channelDescription,      importance: importance,    );    await _flutterLocalNotificationsPlugin        .resolvePlatformSpecificImplementation<            AndroidFlutterLocalNotificationsPlugin>()        ?.createNotificationChannel(channel);  }  // Show notification with image [DONE]  Future<void> showNotificationNow({    int id = 0,    required String title,    required String body,    String? imageUrl,    String? payload,    String channelId = _defaultChannelId,    String channelName = _defaultChannelName,  }) async {    // Check if image is provided    final styleInformation = imageUrl != null        ? BigPictureStyleInformation(            FilePathAndroidBitmap(imageUrl),            largeIcon: FilePathAndroidBitmap(imageUrl),            contentTitle: title,            summaryText: body,          )        : null; // Default style if no image    final androidDetails = AndroidNotificationDetails(      channelId,      channelName,      styleInformation: styleInformation,      importance: Importance.high,      priority: Priority.high,      playSound: true,    );    final notificationDetails = NotificationDetails(android: androidDetails);    await _flutterLocalNotificationsPlugin.show(      id,      title,      body,      notificationDetails,      payload: payload,    );    // print('Send');  }  // Show interactive notification [DONE]  Future<void> showInteractiveNotification({    required int id,    required String title,    required String body,    required List<NotificationAction> actions,    String? payload,    String channelId = _defaultChannelId,    String channelName = _defaultChannelName,  }) async {    final List<AndroidNotificationAction> androidActions = actions        .map(          (action) => AndroidNotificationAction(            action.id,            action.title,          ),        )        .toList();    final androidDetails = AndroidNotificationDetails(      channelId,      channelName,      importance: Importance.high,      priority: Priority.high,      actions: androidActions,    );    final notificationDetails = NotificationDetails(android: androidDetails);    await _flutterLocalNotificationsPlugin.show(      id,      title,      body,      notificationDetails,      payload: payload,    );  }  Future<void> showScheduleDailyNotification({    required int id,    required String title,    required String body,    required int hour, // Correctly pass the desired time    required int minute,    String? payload,    String channelId = _defaultChannelId,    String channelName = _defaultChannelName,  }) async {    tz.setLocalLocation(tz.getLocation("Africa/Cairo"));    final now = tz.TZDateTime.now(tz.local);    // Schedule the notification for the specified time    final tz.TZDateTime firstInstance = tz.TZDateTime(      tz.local,      now.year,      now.month,      now.day,      hour,      minute,    ).isBefore(now)        ? tz.TZDateTime(            tz.local,            now.year,            now.month,            now.day + 1,            hour,            minute,          )        : tz.TZDateTime(            tz.local,            now.year,            now.month,            now.day,            hour,            minute,          );    await _flutterLocalNotificationsPlugin.zonedSchedule(      id,      title,      body,      firstInstance,      // tz.TZDateTime.now(tz.local).add(const Duration(seconds: 10)),      NotificationDetails(        android: AndroidNotificationDetails(          channelId,          channelName,          importance: Importance.max,          priority: Priority.max,          playSound: true,          category: AndroidNotificationCategory.reminder,        ),      ),      payload: 'payload',      uiLocalNotificationDateInterpretation:          UILocalNotificationDateInterpretation.absoluteTime,      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,      matchDateTimeComponents: DateTimeComponents.time,    );    // print("Test is called");  }  // Grouped Notifications  Future<void> showGroupedNotification({    required int groupId,    required String groupKey,    required List<Map<String, String>> notifications,    String summaryTitle = 'Summary',    String summaryBody = 'You have new notifications',    String channelId = _defaultChannelId,    String channelName = _defaultChannelName,  }) async {    for (int i = 0; i < notifications.length; i++) {      final notification = notifications[i];      await _flutterLocalNotificationsPlugin.show(        groupId + i,        notification['title']!,        notification['body']!,        NotificationDetails(          android: AndroidNotificationDetails(            channelId,            channelName,            groupKey: groupKey,            importance: Importance.high,            priority: Priority.high,          ),        ),      );    }    // Summary Notification    await _flutterLocalNotificationsPlugin.show(      groupId,      summaryTitle,      summaryBody,      NotificationDetails(        android: AndroidNotificationDetails(          channelId,          channelName,          groupKey: groupKey,          setAsGroupSummary: true,          importance: Importance.high,          priority: Priority.high,        ),      ),    );  }  Future<void> scheduleSingleNotification({    required int id,    required String title,    required String body,    required DateTime scheduledTime,    String? payload,    String channelId = _defaultChannelId,    String channelName = _defaultChannelName,  }) async {    tz.setLocalLocation(tz.getLocation("Africa/Cairo"));    final DateTime notificationTime =        scheduledTime.subtract(const Duration(minutes: 15));    if (notificationTime.isBefore(tz.TZDateTime.now(tz.local))) {      return;    }    final tz.TZDateTime scheduledDate = tz.TZDateTime(      tz.local,      notificationTime.year,      notificationTime.month,      notificationTime.day,      notificationTime.hour,      notificationTime.minute,    );    print(scheduledDate);    await _flutterLocalNotificationsPlugin.zonedSchedule(      id,      title,      body,      scheduledDate,      NotificationDetails(        android: AndroidNotificationDetails(          channelId,          channelName,          importance: Importance.max,          priority: Priority.max,          playSound: true,          category: AndroidNotificationCategory.reminder,        ),      ),      payload: payload,      uiLocalNotificationDateInterpretation:          UILocalNotificationDateInterpretation.absoluteTime,      matchDateTimeComponents: DateTimeComponents.time,      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,    );  }  Future<void> cancelNotification(int id) async {    await _flutterLocalNotificationsPlugin.cancel(id);  }  Future<void> cancelAllNotifications() async {    await _flutterLocalNotificationsPlugin.cancelAll();  }}// Helper class for actionsclass NotificationAction {  final String id;  final String title;  NotificationAction({    required this.id,    required this.title,  });}class NotificationResponseModel2 {  final int id;  final String? payload;  NotificationResponseModel2({required this.id, this.payload});}