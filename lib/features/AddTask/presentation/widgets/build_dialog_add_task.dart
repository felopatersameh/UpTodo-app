import 'package:flutter/material.dart';import 'package:flutter_bloc/flutter_bloc.dart';import '../../../../core/utils/Widget/build_text_form_field.dart';import '../../../../core/utils/resource/colors.dart';import '../../../../core/utils/resource/string.dart';import '../../../../core/utils/resource/styles.dart';import '../../../AddTask/presentation/widgets/build_category.dart';import '../../../AddTask/presentation/widgets/build_priority.dart';import '../../../AddTask/presentation/widgets/calendar_picker.dart';import '../../../AddTask/presentation/widgets/time_picker.dart';import '../../data/models/category_model.dart';import '../../data/models/priority_model.dart';import '../../../../core/model/task_model.dart';import '../../../Calendar/presentation/manager/calendar_cubit.dart';import '../../../../core/utils/Widget/custom_messages.dart';class DialogAddTask extends StatefulWidget {  const DialogAddTask({super.key});  @override  State<DialogAddTask> createState() => _DialogAddTaskState();}final TextEditingController _title = TextEditingController();final TextEditingController _description = TextEditingController();final GlobalKey<FormState> _keyForm = GlobalKey<FormState>();DateTime? _data;CategoryModel? _categoryModel;PriorityModel? _priorityModel;class _DialogAddTaskState extends State<DialogAddTask> {  final FocusNode _titleFocusNode = FocusNode();  AlignmentGeometry alignment = Alignment.bottomCenter;  @override  void initState() {    _title.clear();    _description.clear();    _data = null;    _categoryModel = null;    _priorityModel = null;    _titleFocusNode.requestFocus();    super.initState();  }  @override  Widget build(BuildContext context) {    return Dialog(      alignment: alignment,      insetPadding: EdgeInsets.zero,      child: ListView(        reverse: true,        shrinkWrap: true,        children: [          Form(            key: _keyForm,            autovalidateMode: AutovalidateMode.onUnfocus,            child: Container(              color: AppColors.secondBackGroundColor,              height: MediaQuery.of(context).size.height * 0.38,              width: MediaQuery.of(context).size.width,              padding: const EdgeInsets.all(25.0),              child: Column(                mainAxisSize: MainAxisSize.max,                crossAxisAlignment: CrossAxisAlignment.start,                children: [                  Padding(                    padding: const EdgeInsets.all(8.0),                    child: Text(                      AppStrings.addTask,                      style: Styles.text20AppBAr(),                    ),                  ),                  const SizedBox(height: 10),                  BuildTextFormField(                    controller: _title,                    hint: AppStrings.title,                    focusNode: _titleFocusNode,                  ),                  const SizedBox(height: 18),                  BuildTextFormField(                    controller: _description,                    hint: AppStrings.description,                  ),                  Expanded(                      child: Center(                          child: Row(                    mainAxisAlignment: MainAxisAlignment.spaceBetween,                    children: [                      Row(                        children: [                          IconButton(                            onPressed: () => _showCalendarPicker(context),                            icon: Icon(                              _data == null                                  ? Icons.timer_outlined                                  : Icons.timer_rounded,                              color: AppColors.iconColor,                            ),                          ),                          IconButton(                            onPressed: () => _buildCategory(context),                            icon: Icon(                                _categoryModel == null                                    ? Icons.sell_outlined                                    : Icons.sell_rounded,                                color: AppColors.iconColor),                          ),                          IconButton(                            onPressed: () => _buildPriority(context),                            icon: Icon(                                _priorityModel == null                                    ? Icons.flag_outlined                                    : Icons.flag_rounded,                                color: AppColors.iconColor),                          ),                        ],                      ),                      IconButton(                        onPressed: () => _onPressed(),                        icon: const Icon(                          Icons.send_outlined,                          color: AppColors.primaryColor,                        ),                      ),                    ],                  ))),                ],              ),            ),          ),        ],      ),    );  }  void _onPressed() {    if (_keyForm.currentState!.validate()) {      if (_data == null) {        showMessage(text: "the date is required", state: ToastStates.error);      } else if (_categoryModel == null) {        showMessage(text: "the category is required", state: ToastStates.error);      } else if (_priorityModel == null) {        showMessage(text: "the priority is required", state: ToastStates.error);      } else {        final task = TaskModel(          _title.text,          _data!,          _categoryModel!,          _priorityModel!,          _description.text,        );        context.read<CalendarCubit>().addTask(task);        showMessage(text: "Succeed", state: ToastStates.succeed);        Navigator.of(context).pop();      }    }  }  Future<void> _showCalendarPicker(BuildContext context) async {    alignment = Alignment.center;    await showDialog(      context: context,      builder: (context) => BuildCalendarPicker(),    ).then((date) async {      if (date != null) {        _data = date;        return _showTimePicker(context);      }      alignment = Alignment.bottomCenter;    });  }  Future<void> _showTimePicker(BuildContext context) async {    await showDialog(      context: context,      builder: (context) => BuildTimePicker(),    ).then((date) {      if (date != null) {        final hour = date[0];        final minute = date[1];        _data = _data!.copyWith(hour: hour, minute: minute);      }      alignment = Alignment.bottomCenter;    });  }  Future<dynamic> _buildCategory(BuildContext context) {    alignment = Alignment.center;    return showAdaptiveDialog(      context: context,      builder: (context) => BuildCategory(),    ).then((p0) {      if (p0 != null) {        _categoryModel = p0;      }      alignment = Alignment.bottomCenter;    });  }  Future<dynamic> _buildPriority(BuildContext context) {    alignment = Alignment.center;    return showDialog(context: context, builder: (context) => BuildPriority())        .then((priority) {      if (priority != null) {        _priorityModel = priority;      }      alignment = Alignment.bottomCenter;    });  }}//******************************************************